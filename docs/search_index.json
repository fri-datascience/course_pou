[["mrv.html", "Chapter 8 Multivariate random variables 8.1 Multinomial random variables 8.2 Multivariate normal random variables 8.3 Non-normal bivariate random variable 8.4 Transformations", " Chapter 8 Multivariate random variables This chapter deals with multivariate random variables. The students are expected to acquire the following knowledge: Theoretical Multinomial distribution. Multivariate normal distribution. Cholesky decomposition. Eigendecomposition. R Sampling from the multinomial distribution. Sampling from the multivariate normal distribution. Matrix decompositions. .fold-btn { float: right; margin: 5px 5px 0 0; } .fold { border: 1px solid black; min-height: 40px; } 8.1 Multinomial random variables Exercise 8.1 Let \\(X_i\\), \\(i = 1,...,k\\) represent \\(k\\) events, and \\(p_i\\) the probabilities of these events happening in a trial. Let \\(n\\) be the number of trials, and \\(X\\) a multivariate random variable, the collection of \\(X_i\\). Then \\(p(x) = \\frac{n!}{x_1!x_2!...x_k!} p_1^{x_1} p_2^{x_2}...p_k^{x_k}\\) is the PMF of a multinomial distribution, where \\(n = \\sum_{i = 1}^k x_i\\). Show that the marginal distribution of \\(X_i\\) is a binomial distribution. Take 1000 samples from the multinomial distribution with \\(n=4\\) and probabilities \\(p = (0.2, 0.2, 0.5, 0.1)\\). Then take 1000 samples from four binomial distributions with the same parameters. Inspect the results visually. Solution. We will approach this proof from the probabilistic point of view. W.L.O.G. let \\(x_1\\) be the marginal distribution we are interested in. The term \\(p^{x_1}\\) denotes the probability that event 1 happened \\(x_1\\) times. For this event not to happen, one of the other events needs to happen. So for each of the remaining trials, the probability of another event is \\(\\sum_{i=2}^k p_i = 1 - p_1\\), and there were \\(n - x_1\\) such trials. What is left to do is to calculate the number of permutations of event 1 happening and event 1 not happening. We choose \\(x_1\\) trials, from \\(n\\) trials. Therefore \\(p(x_1) = \\binom{n}{x_1} p_1^{x_1} (1 - p_1)^{n - x_1}\\), which is the binomial PMF. Interested students are encouraged to prove this mathematically. set.seed(1) nsamps &lt;- 1000 samps_mult &lt;- rmultinom(nsamps, 4, prob = c(0.2, 0.2, 0.5, 0.1)) samps_mult &lt;- as_tibble(t(samps_mult)) %&gt;% gather() samps &lt;- tibble( V1 = rbinom(nsamps, 4, 0.2), V2 = rbinom(nsamps, 4, 0.2), V3 = rbinom(nsamps, 4, 0.5), V4 = rbinom(nsamps, 4, 0.1) ) %&gt;% gather() %&gt;% bind_rows(samps_mult) %&gt;% bind_cols(&quot;dist&quot; = c(rep(&quot;binomial&quot;, 4*nsamps), rep(&quot;multinomial&quot;, 4*nsamps))) ggplot(samps, aes(x = value, fill = dist)) + geom_bar(position = &quot;dodge&quot;) + facet_wrap(~ key) Exercise 8.2 (Multinomial expected value) Find the expected value, variance and covariance of the multinomial distribution. Hint: First find the expected value for \\(n = 1\\) and then use the fact that the trials are independent. Solution. Let us first calculate the expected value of \\(X_1\\), when \\(n = 1\\). \\[\\begin{align} E[X_1] &amp;= \\sum_{n_1 = 0}^1 \\sum_{n_2 = 0}^1 ... \\sum_{n_k = 0}^1 \\frac{1}{n_1!n_2!...n_k!}p_1^{n_1}p_2^{n_2}...p_k^{n_k}n_1 \\\\ &amp;= \\sum_{n_1 = 0}^1 \\frac{p_1^{n_1} n_1}{n_1!} \\sum_{n_2 = 0}^1 ... \\sum_{n_k = 0}^1 \\frac{1}{n_2!...n_k!}p_2^{n_2}...p_k^{n_k} \\end{align}\\] When \\(n_1 = 0\\) then the whole terms is zero, so we do not need to evaluate other sums. When \\(n_1 = 1\\), all other \\(n_i\\) must be zero, as we have \\(1 = \\sum_{i=1}^k n_i\\). Therefore the other sums equal \\(1\\). So \\(E[X_1] = p_1\\) and \\(E[X_i] = p_i\\) for \\(i = 1,...,k\\). Now let \\(Y_j\\), \\(j = 1,...,n\\), have a multinomial distribution with \\(n = 1\\), and let \\(X\\) have a multinomial distribution with an arbitrary \\(n\\). Then we can write \\(X = \\sum_{j=1}^n Y_j\\). And due to independence \\[\\begin{align} E[X] &amp;= E[\\sum_{j=1}^n Y_j] \\\\ &amp;= \\sum_{j=1}^n E[Y_j] \\\\ &amp;= np. \\end{align}\\] For the variance, we need \\(E[X^2]\\). Let us follow the same procedure as above and first calculate \\(E[X_i]\\) for \\(n = 1\\). The only thing that changes is that the term \\(n_i\\) becomes \\(n_i^2\\). Since we only have \\(0\\) and \\(1\\) this does not change the outcome. So \\[\\begin{align} Var[X_i] &amp;= E[X_i^2] - E[X_i]^2\\\\ &amp;= p_i(1 - p_i). \\end{align}\\] Analogous to above for arbitrary \\(n\\) \\[\\begin{align} Var[X] &amp;= E[X^2] - E[X]^2 \\\\ &amp;= \\sum_{j=1}^n E[Y_j^2] - \\sum_{j=1}^n E[Y_j]^2 \\\\ &amp;= \\sum_{j=1}^n E[Y_j^2] - E[Y_j]^2 \\\\ &amp;= \\sum_{j=1}^n p(1-p) \\\\ &amp;= np(1-p). \\end{align}\\] To calculate the covariance, we need \\(E[X_i X_j]\\). Again, let us start with \\(n = 1\\). Without loss of generality, let us assume \\(i = 1\\) and \\(j = 2\\). \\[\\begin{align} E[X_1 X_2] = \\sum_{n_1 = 0}^1 \\sum_{n_2 = 0}^1 \\frac{p_1^{n_1} n_1}{n_1!} \\frac{p_2^{n_2} n_2}{n_2!} \\sum_{n_3 = 0}^1 ... \\sum_{n_k = 0}^1 \\frac{1}{n_3!...n_k!}p_3^{n_3}...p_k^{n_k}. \\end{align}\\] In the above expression, at each iteration we multiply with \\(n_1\\) and \\(n_2\\). Since \\(n = 1\\), one of these always has to be zero. Therefore \\(E[X_1 X_2] = 0\\) and \\[\\begin{align} Cov(X_i, X_j) &amp;= E[X_i X_j] - E[X_i]E[X_j] \\\\ &amp;= - p_i p_j. \\end{align}\\] For arbitrary \\(n\\), let \\(X = \\sum_{t = 1}^n Y_t\\) be the sum of independent multinomial random variables \\(Y_t = [X_{1t}, X_{2t},...,X_{kt}]^T\\) with \\(n=1\\). Then \\(X_1 = \\sum_{t = 1}^n X_{1t}\\) and \\(X_2 = \\sum_{l = 1}^n X_{2l}\\). \\[\\begin{align} Cov(X_1, X_2) &amp;= E[X_1 X_2] - E[X_1] E[X_2] \\\\ &amp;= E[\\sum_{t = 1}^n X_{1t} \\sum_{l = 1}^n X_{2l}] - n^2 p_1 p_2 \\\\ &amp;= \\sum_{t = 1}^n \\sum_{l = 1}^n E[X_{1t} X_{2l}] - n^2 p_1 p_2. \\end{align}\\] For \\(X_{1t}\\) and \\(X_{2l}\\) the expected value is zero when \\(t = l\\). When \\(t \\neq l\\) then they are independent, so the expected value is the product \\(p_1 p_2\\). There are \\(n^2\\) total terms, and for \\(n\\) of them \\(t = l\\) holds. So \\(E[X_1 X_2] = (n^2 - n) p_1 p_2\\). Inserting into the above \\[\\begin{align} Cov(X_1, X_2) &amp;= (n^2 - n) p_1 p_2 - n^2 p_1 p_2 \\\\ &amp;= - n p_1 p_2. \\end{align}\\] 8.2 Multivariate normal random variables Exercise 8.3 (Cholesky decomposition) Let \\(X\\) be a random vector of length \\(k\\) with \\(X_i \\sim \\text{N}(0, 1)\\) and \\(LL^*\\) the Cholesky decomposition of a Hermitian positive-definite matrix \\(A\\). Let \\(\\mu\\) be a vector of length \\(k\\). Find the distribution of the random vector \\(Y = \\mu + L X\\). Find the Cholesky decomposition of \\(A = \\begin{bmatrix} 2 &amp; 1.2 \\\\ 1.2 &amp; 1 \\end{bmatrix}\\). R: Use the results from a) and b) to sample from the MVN distribution \\(\\text{N}(\\mu, A)\\), where \\(\\mu = [1.5, -1]^T\\). Plot a scatterplot and compare it to direct samples from the multivariate normal distribution (rmvnorm). Solution. \\(X\\) has an independent normal distribution of dimension \\(k\\). Then \\[\\begin{align} Y = \\mu + L X &amp;\\sim \\text{N}(\\mu, LL^T) \\\\ &amp;\\sim \\text{N}(\\mu, A). \\end{align}\\] Solve \\[\\begin{align} \\begin{bmatrix} a &amp; 0 \\\\ b &amp; c \\end{bmatrix} \\begin{bmatrix} a &amp; b \\\\ 0 &amp; c \\end{bmatrix} = \\begin{bmatrix} 2 &amp; 1.2 \\\\ 1.2 &amp; 1 \\end{bmatrix} \\end{align}\\] # a set.seed(1) nsamps &lt;- 1000 X &lt;- matrix(data = rnorm(nsamps * 2), ncol = 2) mu &lt;- c(1.5, -1) L &lt;- matrix(data = c(sqrt(2), 0, 1.2 / sqrt(2), sqrt(1 - 1.2^2/2)), ncol = 2, byrow = TRUE) Y &lt;- t(mu + L %*% t(X)) plot_df &lt;- data.frame(rbind(X, Y), c(rep(&quot;X&quot;, nsamps), rep(&quot;Y&quot;, nsamps))) colnames(plot_df) &lt;- c(&quot;D1&quot;, &quot;D2&quot;, &quot;var&quot;) ggplot(data = plot_df, aes(x = D1, y = D2, colour = as.factor(var))) + geom_point() 8.3 Non-normal bivariate random variable Exercise 8.4 (Non-normal bivariate random variable) Find a non-normal bivariate random variable \\((X, Y)\\) with normal marginals. Hint: there are many possible solutions. Try starting with \\(N(0, I)\\), but set density to zero when \\(XY &lt; 0\\). Solution. Let \\(\\varphi(t) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-t^2/2)\\) be the univariate standard normal density. The following bivariate density is one possible solution: \\[\\begin{align} p_{XY}(x,y) = 2 \\varphi(x)\\varphi(y) \\; \\textrm{if}\\; xy&gt;0\\textrm{, and 0 otherwise.} \\end{align}\\] We multiply by \\(2\\) because we took away half the total mass from the original bivariate normal. Proof. Let \\(f(x) = \\int_{0}^\\infty p_{XY}(x, y) dy\\) and \\(g(x) = \\int_{-\\infty}^0 p_{XY}(x, y) dy\\). The marginal \\(p_X(x)\\) is then: \\[\\begin{align} p_X(x) = \\int_{-\\infty}^\\infty p_{XY}(x, y) dy = \\begin{cases} f(x), &amp; x \\ge 0, \\\\ g(x), &amp; x &lt; 0. \\end{cases} \\end{align}\\] Simplify \\(f(x)\\): \\[\\begin{align} f(x) = \\int_{0}^\\infty p_{XY}(x, y) dy = 2\\varphi(x) \\int_{0}^\\infty \\varphi(y) dy = 2\\varphi(x) \\frac{1}{2} = \\varphi(x) \\end{align}\\] Simplify \\(g(x)\\): \\[\\begin{align} f(x) = \\int_{-\\infty}^0 p_{XY}(x, y) dy 2\\varphi(x) \\int_{-\\infty}^0 \\varphi(y) dy = 2\\varphi(x) \\frac{1}{2} = \\varphi(x) \\end{align}\\] Since \\(f(x) = g(x) = \\varphi(x)\\), we conclude that \\(p_X(x) = \\varphi(x)\\) regardless of \\(x\\). Therefore \\(X \\sim N(0, 1)\\) and \\(Y \\sim N(0, 1)\\) by symmetry. Exercise 8.5 (Eigendecomposition) R: Let \\(\\Sigma = U \\Lambda U^T\\) be the eigendecomposition of covariance matrix \\(\\Sigma\\). Follow the procedure below, to sample from a multivariate normal with \\(\\mu = [-2, 1]^T\\) and \\(\\Sigma = \\begin{bmatrix} 0.3, -0.5 \\\\ -0.5, 1.6 \\end{bmatrix}\\): Sample from two independent standardized normal distributions to get \\(X\\). Find the eigendecomposition of \\(X\\) (eigen). Multiply \\(X\\) by \\(\\Lambda^{\\frac{1}{2}}\\) to get \\(X2\\). Consider how the eigendecomposition for \\(X2\\) changes compared to \\(X\\). Multiply \\(X2\\) by \\(U\\) to get \\(X3\\). Consider how the eigendecomposition for \\(X3\\) changes compared to \\(X2\\). Add \\(\\mu\\) to \\(X3\\). Consider how the eigendecomposition for \\(X4\\) changes compared to \\(X3\\). Plot the data and the eigenvectors (scaled with \\(\\Lambda^{\\frac{1}{2}}\\)) at each step. Hint: Use geom_segment for the eigenvectors. # a set.seed(1) sigma &lt;- matrix(data = c(0.3, -0.5, -0.5, 1.6), nrow = 2, byrow = TRUE) ed &lt;- eigen(sigma) e_val &lt;- ed$values e_vec &lt;- ed$vectors # b set.seed(1) nsamps &lt;- 1000 X &lt;- matrix(data = rnorm(nsamps * 2), ncol = 2) vec1 &lt;- matrix(c(1,0,0,1), nrow = 2) X2 &lt;- t(sqrt(diag(e_val)) %*% t(X)) vec2 &lt;- sqrt(diag(e_val)) %*% vec1 X3 &lt;- t(e_vec %*% t(X2)) vec3 &lt;- e_vec %*% vec2 X4 &lt;- t(c(-2, 1) + t(X3)) vec4 &lt;- c(-2, 1) + vec3 vec_mat &lt;- data.frame(matrix(c(0,0,0,0,0,0,0,0,0,0,0,0,-2,1,-2,1), ncol = 2, byrow = TRUE), t(cbind(vec1, vec2, vec3, vec4)), c(1,1,2,2,3,3,4,4)) df &lt;- data.frame(rbind(X, X2, X3, X4), c(rep(1, nsamps), rep(2, nsamps), rep(3, nsamps), rep(4, nsamps))) colnames(df) &lt;- c(&quot;D1&quot;, &quot;D2&quot;, &quot;wh&quot;) colnames(vec_mat) &lt;- c(&quot;D1&quot;, &quot;D2&quot;, &quot;E1&quot;, &quot;E2&quot;, &quot;wh&quot;) ggplot(data = df, aes(x = D1, y = D2)) + geom_point() + geom_segment(data = vec_mat, aes(xend = E1, yend = E2), color = &quot;red&quot;) + facet_wrap(~ wh) + coord_fixed() Exercise 8.6 (Marginal and conditional distributions) Let \\(X \\sim \\text{N}(\\mu, \\Sigma)\\), where \\(\\mu = [2, 0, -1]^T\\) and \\(\\Sigma = \\begin{bmatrix} 1 &amp; -0.2 &amp; 0.5 \\\\ -0.2 &amp; 1.4 &amp; -1.2 \\\\ 0.5 &amp; -1.2 &amp; 2 \\\\ \\end{bmatrix}\\). Let \\(A\\) represent the first two random variables and \\(B\\) the third random variable. R: For the calculation in the following points, you can use R. Find the marginal distribution of \\(B\\). Find the conditional distribution of \\(B | A = [a_1, a_2]^T\\). Find the marginal distribution of \\(A\\). Find the conditional distribution of \\(A | B = b\\). R: Visually compare the distributions of a) and b), and c) and d) at three different conditional values. mu &lt;- c(2, 0, -1) Sigma &lt;- matrix(c(1, -0.2, 0.5, -0.2, 1.4, -1.2, 0.5, -1.2, 2), nrow = 3, byrow = TRUE) mu_A &lt;- c(2, 0) mu_B &lt;- -1 Sigma_A &lt;- Sigma[1:2, 1:2] Sigma_B &lt;- Sigma[3, 3] Sigma_AB &lt;- Sigma[1:2, 3] # b tmp_b &lt;- t(Sigma_AB) %*% solve(Sigma_A) mu_b &lt;- mu_B - tmp_b %*% mu_A Sigma_b &lt;- Sigma_B - t(Sigma_AB) %*% solve(Sigma_A) %*% Sigma_AB mu_b ## [,1] ## [1,] -1.676471 tmp_b ## [,1] [,2] ## [1,] 0.3382353 -0.8088235 Sigma_b ## [,1] ## [1,] 0.8602941 # d tmp_a &lt;- Sigma_AB * (1 / Sigma_B) mu_a &lt;- mu_A - tmp_a * mu_B Sigma_d &lt;- Sigma_A - (Sigma_AB * (1 / Sigma_B)) %*% t(Sigma_AB) mu_a ## [1] 2.25 -0.60 tmp_a ## [1] 0.25 -0.60 Sigma_d ## [,1] [,2] ## [1,] 0.875 0.10 ## [2,] 0.100 0.68 Solution. \\(B \\sim \\text{N}(-1, 2)\\). \\(B | A = a \\sim \\text{N}(-1.68 + [0.34, -0.81] a, 0.86)\\). \\(\\mu_A = [2, 0]^T\\) and \\(\\Sigma_A = \\begin{bmatrix} 1 &amp; -0.2 &amp; \\\\ -0.2 &amp; 1.4 \\\\ \\end{bmatrix}\\). \\[\\begin{align} A | B = b &amp;\\sim \\text{N}(\\mu_t, \\Sigma_t), \\\\ \\mu_t &amp;= [2.25, -0.6]^T + [0.25, -0.6]^T b, \\\\ \\Sigma_t &amp;= \\begin{bmatrix} 0.875 &amp; 0.1 \\\\ 0.1 &amp; 0.68 \\\\ \\end{bmatrix} \\end{align}\\] library(mvtnorm) set.seed(1) nsamps &lt;- 1000 # a and b samps &lt;- as.data.frame(matrix(data = NA, nrow = 4 * nsamps, ncol = 2)) samps[1:nsamps,1] &lt;- rnorm(nsamps, mu_B, Sigma_B) samps[1:nsamps,2] &lt;- &quot;marginal&quot; for (i in 1:3) { a &lt;- rmvnorm(1, mu_A, Sigma_A) samps[(i*nsamps + 1):((i + 1) * nsamps), 1] &lt;- rnorm(nsamps, mu_b + tmp_b %*% t(a), Sigma_b) samps[(i*nsamps + 1):((i + 1) * nsamps), 2] &lt;- paste0(# &quot;cond&quot;, round(a, digits = 2), collapse = &quot;-&quot;) } colnames(samps) &lt;- c(&quot;x&quot;, &quot;dist&quot;) ggplot(samps, aes(x = x)) + geom_density() + facet_wrap(~ dist) # c and d samps &lt;- as.data.frame(matrix(data = NA, nrow = 4 * nsamps, ncol = 3)) samps[1:nsamps,1:2] &lt;- rmvnorm(nsamps, mu_A, Sigma_A) samps[1:nsamps,3] &lt;- &quot;marginal&quot; for (i in 1:3) { b &lt;- rnorm(1, mu_B, Sigma_B) samps[(i*nsamps + 1):((i + 1) * nsamps), 1:2] &lt;- rmvnorm(nsamps, mu_a + tmp_a * b, Sigma_d) samps[(i*nsamps + 1):((i + 1) * nsamps), 3] &lt;- b } colnames(samps) &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;dist&quot;) ggplot(samps, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;) + facet_wrap(~ dist) 8.4 Transformations Exercise 8.7 Let \\((U,V)\\) be a random variable with PDF \\(p(u,v) = \\frac{1}{4 \\sqrt{u}}\\), \\(U \\in [0,4]\\) and \\(V \\in [\\sqrt{U}, \\sqrt{U} + 1]\\). Let \\(X = \\sqrt{U}\\) and \\(Y = V - \\sqrt{U}\\). Find PDF of \\((X,Y)\\). What can you tell about distributions of \\(X\\) and \\(Y\\)? This exercise shows how we can simplify a probabilistic problem with a clever use of transformations. R: Take 1000 samples from \\((X,Y)\\) and transform them with inverses of the above functions to get samples from \\((U,V)\\). Plot both sets of samples. Solution. First we need to find the inverse functions. Since \\(x = \\sqrt{u}\\) it follows that \\(u = x^2\\), and that \\(x \\in [0,2]\\). Similarly \\(v = y + x\\) and \\(y \\in [0,1]\\). Let us first find the Jacobian. \\[\\renewcommand\\arraystretch{1.6} J(x,y) = \\begin{bmatrix} \\frac{\\partial u}{\\partial x} &amp; \\frac{\\partial v}{\\partial x} \\\\%[1ex] % &lt;-- 1ex more space between rows of matrix \\frac{\\partial u}{\\partial y} &amp; \\frac{\\partial v}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} 2x &amp; 1 \\\\%[1ex] % &lt;-- 1ex more space between rows of matrix 0 &amp; 1 \\end{bmatrix}, \\] and the determinant is \\(|J(x,y)| = 2x\\). Putting everything together, we get \\[\\begin{align} p_{X,Y}(x,y) = p_{U,V}(x^2, y + x) |J(x,y)| = \\frac{1}{4 \\sqrt{x^2}} 2x = \\frac{1}{2}. \\end{align}\\] This reminds us of the Uniform distribution. Indeed we can see that \\(p_X(x) = \\frac{1}{2}\\) and \\(p_Y(y) = 1\\). So instead of dealing with an awkward PDF of \\((U,V)\\) and the corresponding dynamic bounds, we are now looking at two independent Uniform random variables. In practice, this could make modeling much easier. set.seed(1) nsamps &lt;- 2000 x &lt;- runif(nsamps, min = 0, max = 2) y &lt;- runif(nsamps) orig &lt;- tibble(x = x, y = y, vrs = &quot;original&quot;) u &lt;- x^2 v &lt;- y + x transf &lt;- tibble(x = u, y = v, vrs = &quot;transformed&quot;) df &lt;- bind_rows(orig, transf) ggplot(df, aes(x = x, y = y, color = vrs)) + geom_point(alpha = 0.3) Exercise 8.8 The following is an adaptation of exercise 6.53 from Ross: A first course in probability. Let \\((X, Y)\\) be a bivariate random variable with \\(X \\sim \\mathrm{Uniform}(0, 1)\\) and \\(Y \\sim \\mathrm{Uniform}(0, 1)\\). Let \\(R = \\sqrt{X^2 + Y^2}\\) and \\(\\Theta = \\tan^{-1}(Y / X)\\). Find the joint PDF of \\((R, \\Theta)\\). Solution. Define: \\(f([x, y]) = [r, \\theta]\\). The inverse is \\(f^{-1}([r, \\theta]) = [r \\cos \\theta, r \\sin \\theta]\\). We want to find \\(p_{R\\Theta}(r, \\theta)\\) by applying the change-of-variables formula: \\[\\begin{align} p_{R\\Theta}([r, \\theta]) = p_{XY}(f^{-1}([r, \\theta])) |\\det J_{f^{-1}} ([r, \\theta])|. \\end{align}\\] Since \\(X, Y \\sim \\mathrm{Uniform}(0, 1)\\), we conclude that \\(p_XY([x, y]) = 1\\) for all valid inputs \\(x, y \\in [0, 1]\\). The Jacobian of \\(f^{-1}\\) equals: \\[\\begin{align} J_{f^{-1}} = \\begin{bmatrix} \\frac{\\partial r \\cos \\theta}{\\partial r} &amp; \\frac{\\partial r \\cos \\theta}{\\partial \\theta} \\\\ \\frac{\\partial r \\sin \\theta}{\\partial r} &amp; \\frac{\\partial r \\sin \\theta}{\\partial \\theta} \\end{bmatrix} = \\begin{bmatrix} \\cos \\theta &amp; -r \\sin \\theta \\\\ \\sin \\theta &amp; r \\cos \\theta \\end{bmatrix}. \\end{align}\\] The determinant equals: \\[\\begin{align} \\det J_{f^{-1}} &amp;= \\cos \\theta \\cdot r \\cos \\theta - (\\sin \\theta \\cdot (-\\sin \\theta)) \\\\ &amp;= r (\\cos \\theta)^2 + r (\\sin \\theta)^2 = r ((\\cos \\theta)^2 + (\\sin \\theta)^2) = r. \\end{align}\\] The final joint density is thus: \\[\\begin{align} p_{R\\Theta}([r, \\theta]) &amp;= p_{XY}(f^{-1}([r, \\theta])) |\\det J_{f^{-1}} ([r, \\theta])| \\\\ &amp;= 1 |r| = r. \\end{align}\\] Exercise 8.9 R: Write a function that will calculate the probability density of an arbitraty multivariate normal distribution, based on independent standardized normal PDFs. Compare with dmvnorm from the mvtnorm package. library(mvtnorm) set.seed(1) mvn_dens &lt;- function (y, mu, Sigma) { L &lt;- chol(Sigma) L_inv &lt;- solve(t(L)) g_inv &lt;- L_inv %*% t(y - mu) J &lt;- L_inv J_det &lt;- det(J) return(prod(dnorm(g_inv)) * J_det) } mu_v &lt;- c(-2, 0, 1) cov_m &lt;- matrix(c(1, -0.2, 0.5, -0.2, 2, 0.3, 0.5, 0.3, 1.6), ncol = 3, byrow = TRUE) n_comp &lt;- 20 for (i in 1:n_comp) { x &lt;- rmvnorm(1, mean = mu_v, sigma = cov_m) print(paste0(&quot;My function: &quot;, mvn_dens(x, mu_v, cov_m), &quot;, dmvnorm: &quot;, dmvnorm(x, mu_v, cov_m))) } ## [1] &quot;My function: 0.0229514237156383, dmvnorm: 0.0229514237156383&quot; ## [1] &quot;My function: 0.00763138915406231, dmvnorm: 0.00763138915406232&quot; ## [1] &quot;My function: 0.0230688881105741, dmvnorm: 0.0230688881105741&quot; ## [1] &quot;My function: 0.0113616213114732, dmvnorm: 0.0113616213114732&quot; ## [1] &quot;My function: 0.00151808500121908, dmvnorm: 0.00151808500121908&quot; ## [1] &quot;My function: 0.0257658045974509, dmvnorm: 0.0257658045974509&quot; ## [1] &quot;My function: 0.0157963825730805, dmvnorm: 0.0157963825730805&quot; ## [1] &quot;My function: 0.00408856287529248, dmvnorm: 0.00408856287529248&quot; ## [1] &quot;My function: 0.0327793540101256, dmvnorm: 0.0327793540101256&quot; ## [1] &quot;My function: 0.0111606542967978, dmvnorm: 0.0111606542967978&quot; ## [1] &quot;My function: 0.0147636757585684, dmvnorm: 0.0147636757585684&quot; ## [1] &quot;My function: 0.0142948300412208, dmvnorm: 0.0142948300412208&quot; ## [1] &quot;My function: 0.0203093820657542, dmvnorm: 0.0203093820657542&quot; ## [1] &quot;My function: 0.0287533273357481, dmvnorm: 0.0287533273357481&quot; ## [1] &quot;My function: 0.0213402305128623, dmvnorm: 0.0213402305128623&quot; ## [1] &quot;My function: 0.0218356957993885, dmvnorm: 0.0218356957993885&quot; ## [1] &quot;My function: 0.0250750113961771, dmvnorm: 0.0250750113961771&quot; ## [1] &quot;My function: 0.0166498666348048, dmvnorm: 0.0166498666348048&quot; ## [1] &quot;My function: 0.0018972510687466, dmvnorm: 0.0018972510687466&quot; ## [1] &quot;My function: 0.0196697814975113, dmvnorm: 0.0196697814975113&quot; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
